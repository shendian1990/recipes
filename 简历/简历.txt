我于17年从华中科技大学毕业后，就职于上海华信证券的C++后台研发部门，
在华信证券工作期间，我主要负责证券交易API的实现。证券交易接口是为了为研发部门，测试提供简单快捷的查询功能而开发的，后期考虑推向市场。其主要目标就是快速响应，接口简单
该接口采用TCP长连接传输protobuf消息与服务端通信，其登陆，下单等非阻塞接口都是C++11的functional/bind形式的回调仿函数，方便编写，单线程模型
由于该api主要功能时提供查询消息的返回结果，并不涉及到大规模的计算，因此使用单线程模型绰绰有余。
由于采用libvent作为底层，因此具有优秀的跨平台特性和高性能
使用vector<char>作为应用层缓冲区，对外表现为一块连续的内存(char*， len)，方便客户代码编写
其size()可以自动增长，以适应不同大小的消息，他不是一个定长数组
实现了基于protobuf的编解码器和消息分发功能，即接收方收到Protobuf消息数据后自动创建Protobuf Message对象
Google Protobuf 本身具有很强的反射 (reflection) 功能，可以根据 消息名创建具体类型的 Message 对象。
codec 的基本功能之一是做 TCP 分包：确定每条消息的长度，为消息划分界限。在 non-blocking 网络编程中， codec 几乎是必不可少的。如果只收到了半条消
息，那么不会触发消息事件回调，数据会停留在 Buffer 里（数据已经读到 Buffer中了），等待收到一个完整的消息再通知处理函数。
ProtobufCodec 在实际使用中有明显的不足：它只负责把 muduo::net::Buffer 转换为具体类型的 protobuf::Message，应用程序拿到 Message 之后还有再根据其具体类型
做一次分发。我们可以考虑做一个简单通用的分发器 dispatcher
dispatcher使用map<string,std::function>callbacks_来记录消息名对应的处理函数。当消息到来时，便处理

在网络编程中使用protobuf需要解决2个问题：1. 长度， protobuf 打包的数据没有自带长度信息或终结符，需要由应用程序自己在发生和接收的时候做正确的切分；
2. 类型， protobuf 打包的数据没有自带类型信息，需要由发送方把类型信息传给给接收方，接收方创建具体的 Protobuf Message 对象，再做的反序列化

每个线程只有一个事件循环对象


Reactor模式首先是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers。这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler
Handle：由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接（Connection，在Java NIO中的Channel）。这个Channel注册到Synchronous Event Demultiplexer中，以监听Handle中发生的事件，对ServerSocketChannnel可以是CONNECT事件，对SocketChannel可以是READ、WRITE、CLOSE事件等。
Synchronous Event Demultiplexer：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。在Java NIO中用Selector来封装，当Selector.select()返回时，可以调用Selector的selectedKeys()方法获取Set<SelectionKey>，一个SelectionKey表达一个有事件发生的Channel以及该Channel上的事件类型。上图的“Synchronous Event Demultiplexer ---notifies--> Handle”的流程如果是对的，那内部实现应该是select()方法在事件到来后会先设置Handle的状态，然后返回。
Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。
Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。
Concrete Event Handler：事件EventHandler接口，实现特定事件处理逻辑。

Reactor：反应器，定义一个接口，实现以下功能：
1）供应用程序注册和删除关注的事件句柄；
2）运行事件循环；
3）有就绪事件到来时，分发事件到之前注册的回调函数上处理；


Reactor模式详解

优点

1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的； 
2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销； 
3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源； 
4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；
缺点

1）相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。 
2）Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。 
3） Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。