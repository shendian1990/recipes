我于17年从华中科技大学毕业后，就职于上海华信证券的C++后台研发部门，
在华信证券工作期间，我主要负责证券交易API的实现。证券交易接口是为了为研发部门，测试提供简单快捷的查询功能而开发的，后期考虑推向市场。其主要目标就是快速响应，接口简单
该接口采用TCP长连接传输protobuf消息与服务端通信，其登陆，下单等非接口都是C++11的functional/bind形式的回调仿函数，方便编写，单线程模型
由于该api主要功能时提供查询消息的返回结果，并不涉及到大规模的计算，因此使用单线程模型绰绰有余。
由于采用libvent作为底层，因此具有优秀的跨平台特性和高性能
使用vector<char>作为应用层缓冲区，对外表现为一块连续的内存(char*， len)，方便客户代码编写
其size()可以自动增长，以适应不同大小的消息，他不是一个定长数组
实现了基于protobuf的编解码器和消息分发功能，即接收方收到Protobuf消息数据后自动创建Protobuf Message对象
Google Protobuf 本身具有很强的反射 (reflection) 功能，可以根据 消息名创建具体类型的 Message 对象。
codec 的基本功能之一是做 TCP 分包：确定每条消息的长度，为消息划分界限。在 non-blocking 网络编程中， codec 几乎是必不可少的。如果只收到了半条消
息，那么不会触发消息事件回调，数据会停留在 Buffer 里（数据已经读到 Buffer中了），等待收到一个完整的消息再通知处理函数。
ProtobufCodec 在实际使用中有明显的不足：它只负责把 muduo::net::Buffer 转换为具体类型的 protobuf::Message，应用程序拿到 Message 之后还有再根据其具体类型
做一次分发。我们可以考虑做一个简单通用的分发器 dispatcher
dispatcher使用map<string,std::function>callbacks_来记录消息名对应的处理函数。当消息到来时，便处理

在网络编程中使用protobuf需要解决2个问题：1. 长度， protobuf 打包的数据没有自带长度信息或终结符，需要由应用程序自己在发生和接收的时候做正确的切分；
2. 类型， protobuf 打包的数据没有自带类型信息，需要由发送方把类型信息传给给接收方，接收方创建具体的 Protobuf Message 对象，再做的反序列化